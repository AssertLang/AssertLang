{
  "name": "AssertLang",
  "scopeName": "source.al",
  "fileTypes": ["al"],
  "patterns": [
    { "include": "#comments" },
    { "include": "#contract-decorators" },
    { "include": "#keywords" },
    { "include": "#types" },
    { "include": "#type-annotations" },
    { "include": "#strings" },
    { "include": "#numbers" },
    { "include": "#functions" },
    { "include": "#stdlib-functions" },
    { "include": "#operators" },
    { "include": "#constants" }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.al",
          "match": "//.*$"
        },
        {
          "name": "comment.block.al",
          "begin": "/\\*",
          "end": "\\*/"
        }
      ]
    },
    "contract-decorators": {
      "patterns": [
        {
          "name": "meta.decorator.contract.al",
          "match": "@(requires|ensures|invariant|precondition|postcondition)\\s+([a-zA-Z_][a-zA-Z0-9_]*)",
          "captures": {
            "1": { "name": "storage.type.annotation.al" },
            "2": { "name": "variable.other.constant.al" }
          }
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.al",
          "match": "\\b(if|else|for|while|return|break|continue|try|catch|finally|throw|match|case)\\b"
        },
        {
          "name": "keyword.declaration.al",
          "match": "\\b(function|let|const|var|class|interface|enum|contract|struct|type)\\b"
        },
        {
          "name": "storage.modifier.al",
          "match": "\\b(public|private|protected|static|async|await|mut)\\b"
        },
        {
          "name": "keyword.other.al",
          "match": "\\b(require|assert|expect|Some|None|Ok|Err)\\b"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "support.type.primitive.al",
          "match": "\\b(int|float|string|bool|void|any|never)\\b"
        },
        {
          "name": "support.type.builtin.al",
          "match": "\\b(list|map|set|array|dict|tuple|Option|Result|Error)\\b"
        },
        {
          "name": "entity.name.type.al",
          "match": "\\b([A-Z][a-zA-Z0-9_]*)\\b"
        }
      ]
    },
    "type-annotations": {
      "patterns": [
        {
          "name": "meta.type.annotation.al",
          "match": ":\\s*([a-zA-Z_][a-zA-Z0-9_<>,\\[\\]\\s]*)",
          "captures": {
            "1": { "name": "entity.name.type.al" }
          }
        },
        {
          "name": "meta.return.type.al",
          "match": "->\\s*([a-zA-Z_][a-zA-Z0-9_<>,\\[\\]\\s]*)",
          "captures": {
            "0": { "name": "keyword.operator.arrow.al" },
            "1": { "name": "entity.name.type.al" }
          }
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.al",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.al",
              "match": "\\\\(n|r|t|\\\\|\"|'|u[0-9a-fA-F]{4})"
            }
          ]
        },
        {
          "name": "string.quoted.single.al",
          "begin": "'",
          "end": "'",
          "patterns": [
            {
              "name": "constant.character.escape.al",
              "match": "\\\\(n|r|t|\\\\|\"|')"
            }
          ]
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.float.al",
          "match": "\\b[0-9]+\\.[0-9]+([eE][+-]?[0-9]+)?\\b"
        },
        {
          "name": "constant.numeric.integer.al",
          "match": "\\b(0x[0-9a-fA-F]+|0o[0-7]+|0b[01]+|[0-9]+)\\b"
        }
      ]
    },
    "functions": {
      "patterns": [
        {
          "name": "meta.function.call.al",
          "match": "\\b([a-z_][a-zA-Z0-9_]*)\\s*(?=\\()",
          "captures": {
            "1": { "name": "entity.name.function.al" }
          }
        },
        {
          "name": "meta.function.declaration.al",
          "match": "\\bfunction\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?=\\()",
          "captures": {
            "1": { "name": "entity.name.function.declaration.al" }
          }
        }
      ]
    },
    "stdlib-functions": {
      "patterns": [
        {
          "name": "support.function.stdlib.al",
          "match": "\\b(str|list|map|set|option|result)\\.(length|contains|get|set|push|pop|insert|remove|filter|map|reduce|fold|unwrap|expect|is_some|is_none|is_ok|is_err|and_then|or_else|match)\\b"
        },
        {
          "name": "support.function.builtin.al",
          "match": "\\b(print|println|panic|assert|expect|debug|format|timestamp)\\b"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.comparison.al",
          "match": "(==|!=|<|>|<=|>=)"
        },
        {
          "name": "keyword.operator.logical.al",
          "match": "(&&|\\|\\||!)"
        },
        {
          "name": "keyword.operator.arithmetic.al",
          "match": "(\\+|\\-|\\*|\\/|%)"
        },
        {
          "name": "keyword.operator.assignment.al",
          "match": "(=|\\+=|\\-=|\\*=|\\/=|%=)"
        },
        {
          "name": "keyword.operator.arrow.al",
          "match": "(->|=>)"
        },
        {
          "name": "keyword.operator.accessor.al",
          "match": "(\\.)"
        }
      ]
    },
    "constants": {
      "patterns": [
        {
          "name": "constant.language.boolean.al",
          "match": "\\b(true|false)\\b"
        },
        {
          "name": "constant.language.null.al",
          "match": "\\b(null|nil|None)\\b"
        },
        {
          "name": "variable.language.this.al",
          "match": "\\b(self|this)\\b"
        }
      ]
    }
  }
}
